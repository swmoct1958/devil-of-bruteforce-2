# 全探索の悪魔 ―― 多言語実装で挑むNP問題の深淵
## 魔法陣 ―― 10の言語で解き明かすバックトラッキングの美学

===

### 第0章：はじめに

　前著『全探索の魔 Ⅰ ―― n-Queen問題』では、チェス盤の上にクイーンを配置するという一見単純な問題の背後に潜む、NP問題の深淵を覗き見た。そこにあったのは、指数関数的に膨れ上がる計算量という「悪魔」との対峙であり、それをねじ伏せるためのバックトラッキングという「知恵」の記録であった。

　本書、第2巻で挑むのは「魔法陣（魔方陣）」である。

　n-Queen問題が「置けない場所」を消去していく消去法のパズルであったのに対し、魔法陣は「縦・横・対角線の和を一定にする」という、等式制約のパズルである。一見すると制約が強まったことで探索は容易になるかと思いきや、その探索空間の広大さはn-Queenを遥かに凌駕する。$3 \times 3$ の魔法陣（九宮図）から始まり、$4 \times 4$、そしてその先へ。次数が一つ上がるごとに、我々は再び $O((n^2)!)$ という絶望的な計算量の壁に突き当たることになる。

　本書でも、私が長年親しんできた C、C++、Java、Python はもちろん、大学時代に出会った Fortran や Pascal、そして現代の Rust まで、計8つの言語を用いてこの問題に挑む。

　なぜ、一つの問題を解くのにこれほど多くの言語を必要とするのか。それは、言語が変われば「問題の見え方」が変わるからだ。メモリの型を意識する C の視点、オブジェクトの堅牢性を重んじる Java の視点、そして配列演算の美学を持つ Fortran の視点。それらは、一つの真理を異なる角度から照らす「多焦点レンズ」となり、読者のエンジニアリングにおける視界をよりクリアにするだろう。

　還暦を過ぎてなお、新しい言語に触れるたびに発見がある。全探索という愚直な手法の中にこそ、プログラミングの本質的な喜びが隠されている。さあ、再びコードという名の松明を手に、魔法陣が描き出す数の調和の世界へ踏み込もう。

===

### 第1章：組合せの迷宮 ―― 魔法陣の数学的性質

魔法陣（魔方陣）は、単なるパズルを超え、古代から数学者を虜にしてきた「数の調和」の象徴です。本章では、全探索という「力業」に挑む前に、我々を導く北極星となる数学的な制約を整理します。

#### 1-1. 定数和 $S = \frac{n(n^2+1)}{2}$ の導出
魔法陣の定義は、 $n \times n$ の正方形に $1$ から $n^2$ までの数字を重複なく配置し、縦・横・対角線の各列の和をすべて等しくすることです。この等しくなる和を「定数和（魔法和）」と呼びます。

この $S$ の値は、以下の論理で導き出せます。
1. $1$ から $m$ までの総和は $\frac{m(m+1)}{2}$ である。
2. 魔法陣には $1$ から $n^2$ までの数が入るため、全体の総和は $m = n^2$ を代入し、 $\frac{n^2(n^2+1)}{2}$ となる。
3. 全 $n$ 行の和がすべて $S$ になる必要があるため、全体の総和を $n$ で割ることで、一行あたりの和 $S$ が求まる。

$$S = \frac{n^2(n^2+1)}{2n} = \frac{n(n^2+1)}{2}$$



たとえば、$3 \times 3$ なら $S=15$、$4 \times 4$ なら $S=34$ となり、これが全探索における最も重要な「チェック基準」となります。

#### 1-2. $O((n^2)!)$ の衝撃：n-Queenを超える絶望的な探索空間
前著で扱った n-Queen問題では、クイーンを各行に一つずつ置くという制約から、探索空間は $n!$ 程度に抑えられていました。しかし、魔法陣は過酷です。

$n \times n$ のマス目に $1$ から $n^2$ までの異なる数字を並べる組み合わせは、 $(n^2)!$ 通り存在します。
* **$3 \times 3$ ($n=3$):** $9! = 362,880$ 通り。
* **$4 \times 4$ ($n=4$):** $16! \approx 2.09 \times 10^{13}$ 通り。
* **$5 \times 5$ ($n=5$):** $25! \approx 1.55 \times 10^{25}$ 通り。

この指数関数的どころではない爆発的な増加こそが、魔法陣を「全探索の迷宮」たらしめている理由です。工夫のない全探索は、 $n=4$ でさえ現代の計算機に数時間の負荷を強いることになります。

===

### 第2章：設計図 ―― 制約充足と枝切りの論理

多言語で実装を比較する前に、まずは言語に依存しない共通の「論理の設計図」を定義します。n-Queen問題と同様に、広大な探索空間を効率よく渡り歩くためには、数学的制約をいかに早くコードに落とし込むかが鍵となります。

#### 2-1. 言語に依存しないアルゴリズムの日本語骨子
基本戦略は、空のマス目に $1$ から $n^2$ までの未使用の数字を順に埋めていくバックトラッキング法です。
1. 未使用の数字から一つ選び、現在のマスに配置する。
2. その数字を置いたことで、すでに確定した行・列・対角線の和が $S$ と矛盾しないか確認する。
3. 矛盾がなければ次のマスへ進み（再帰）、矛盾があれば数字を取り除いて別の候補を試す（枝切り）。

#### 2-2. 枝切りの極意：行・列・対角線が「和」を超えた瞬間の探索打ち切り
魔法陣の探索を加速させる肝は、「いつ、探索を諦めるか」にあります。
* **超過チェック**: まだマスが埋まっていない途中段階でも、その時点の合計が $S$ を超えていれば、その先を探索しても解は見つかりません。
* **行の完成**: 一行が埋まった瞬間にその和が $S$ でなければ、即座にその枝を切り捨てます。
* **最後のマスの確定**: 各行・列の最後のマスは、選択の余地はありません。残りの合計から逆算される特定の数値である必要があります。その数値が「未使用」かつ「範囲内」でなければ、その時点で失敗とみなします。

#### 2-3. 対称性の排除：回転・反転による重複解をどう定義するか
ひとつの魔法陣が見つかると、それを回転（90度、180度、270度）させたり、鏡のように反転させたりすることで、合計 8 通りのバリエーションが生まれます。
これらをすべて個別の解としてカウントすると、本質的な解の 8 倍の数が出てしまいます。これを防ぐために、例えば「左上の角が右上の角より小さい」といった制約を設け、正規化された解のみを抽出する論理を実装に組み込みます。

===

### 第3章 Python ―― 直感と簡潔さの極み

#### Pythonが体現する「エレガンス」
Pythonの設計哲学である「The Zen of Python」には、```Simple is better than complex（複雑であるよりは、単純である方が良い）``` という言葉があります。魔法陣の実装においても、Pythonは第2章で描いた「設計図」を最も美しく、そして直感的に写し取ることができます。

##### 実装のポイント
* 3-1. スライスとリスト内包表記による盤面管理：Python特有の柔軟な配列操作は、行列の和を検証するロジックを簡潔に記述することを可能にします。
* 3-2. 動的型付けがもたらすプロトタイピングの速さ：一人法人として、論理の正当性を素早く検証し、論理の欠陥を洗い出すフェーズにおいて、Pythonの右に出る言語はありません。

##### Pythonによる実装コード
```python
def solve_magic_square_n4():
    n = 4
    s = 34
    board = [0] * 16
    used = [False] * 17
    
    # 4次の魔方陣の各行・列・対角線のインデックス定義
    # 言語特性：リストによる構造化とインデックスアクセス
    ROWS = [range(i*4, (i+1)*4) for i in range(4)]
    COLS = [range(i, 16, 4) for i in range(4)]
    DIAGS = [range(0, 16, 5), range(3, 13, 3)]

    def is_valid_sum(indices):
        """指定されたインデックスの合計が34か確認する"""
        return sum(board[i] for i in indices) == s

    def backtrack(pos):
        # 1行埋まるごとにチェック（Pythonの論理的な枝切り）
        if pos in [4, 8, 12]:
            if not is_valid_sum(ROWS[pos // 4 - 1]):
                return 0

        if pos == 16:
            # 最終行の確認
            if not is_valid_sum(ROWS[3]): return 0
            # 全列の確認
            if any(not is_valid_sum(c) for c in COLS): return 0
            # 全対角線の確認
            if any(not is_valid_sum(d) for d in DIAGS): return 0
            return 1

        count = 0
        for val in range(1, 17):
            if not used[val]:
                used[val] = True
                board[pos] = val
                count += backtrack(pos + 1)
                used[val] = False
        return count

    print("探索中...")
    total = backtrack(0)
    print(f"4次魔方陣の解の総数: {total}")

if __name__ == "__main__":
    solve_magic_square_n4()
```
##### 著者による考察
このコードの美しさは、```「何をするか」がそのまま「書いてある」``` 点にあります。受託開発において、納期が厳しく、仕様変更が頻発するフェーズでは、このような「読み違えの起きないコード」が最大の武器になります。しかし、計算速度という面では、Pythonは広大な探索空間に対しては非力です。

次節では、この「論理」を維持したまま、速度の極限に挑むC++の世界へ足を踏み入れます。

===

### 第4章 C++ ―― ビット演算によるCPUへの挑戦

#### 4-1. マシンの鼓動を感じる「厳密さ」
C++は、Pythonとは対照的に```ハードウェアに近い場所```で動作する言語です。メモリ管理や型定義に厳格である分、開発者が意図した通りの最適化をCPUに命令することができます。魔法陣の探索空間を高速に走破するために、C++が持つ「厳密さ」を最大限に引き出します。

##### 実装のポイント
* 4-1. ビット演算による高速判定：縦・列・斜めの衝突判定を、配列のループではなく「1ビットの論理演算」で瞬時に行う手法を導入します。
* 4-2. テンプレートとインライン展開：次数 n をコンパイル時定数として扱うことで、ループの展開を促し、実行効率を極限まで高めます。

##### C++による高速実装コード
```cpp
#include <iostream>
#include <vector>
#include <chrono>

// ビット演算を用いた魔法陣の高速探索
void solve(int row, int col_mask, int left_mask, int right_mask) {
    if (row == N) {
        total_solutions++;
        return;
    }
    int pos = all_mask & ~(col_mask | left_mask | right_mask);
    while (pos) {
        int bit = -pos & pos;
        pos -= bit;
        solve(row + 1, col_mask | bit, (left_mask | bit) << 1, (right_mask | bit) >> 1);
    }
}
```

#### 4-2. 著者による考察
Pythonでは「盤面の配列」を操作していましたが、このC++コードでは盤面を```ビットの連なり```として扱っています。この「ビットで世界を記述する」感覚こそが、CやC++を扱うエンジニアが持つ特有の快感であり、受託開発においても```計算資源を最小限に抑える```ための必須技能です。

===

### 第5章 C ―― ポインタとメモリの原風景

#### 5-1. 抽象化を削ぎ落とした「純粋な論理」
C++からクラスやテンプレートといった装飾を剥ぎ取ると、そこに現れるのは「関数とポインタ」という極めてシンプルな世界です。C言語による実装は、高級言語が隠蔽している「メモリの振る舞い」を私たちに再認識させてくれます。受託開発の現場でも、ハードウェアに近いレイヤーでは、今なおこの「剥き出しのC」が最強の武器となります。

##### 実装のポイント
* 5-1. 静的メモリ確保：無駄なヒープメモリの動的確保を避け、スタック領域を使い倒す設計を徹底します。
* 5-2. ポインタによる高速アクセス：配列のインデックス参照ではなく、ポインタを直接進めることで、演算のオーバーヘッドを極限まで削ぎ落とします。

```C
##### Cによる純粋実装コード
#include <stdio.h>
#include <stdbool.h>
#include <time.h> // 時間計測用

// 魔法陣の判定
bool is_magic(int n, int board[], int target) {
    int i, j, sum;
    for (i = 0; i < n; i++) {
        sum = 0;
        for (j = 0; j < n; j++) sum += board[i * n + j];
        if (sum != target) return false;
    }
    for (i = 0; i < n; i++) {
        sum = 0;
        for (j = 0; j < n; j++) sum += board[j * n + i];
        if (sum != target) return false;
    }
    int d1 = 0, d2 = 0;
    for (i = 0; i < n; i++) {
        d1 += board[i * n + i];
        d2 += board[i * n + (n - 1 - i)];
    }
    return (d1 == target && d2 == target);
}

void solve(int step, int n, int board[], bool used[], int target, int *count) {
    if (step == n * n) {
        if (is_magic(n, board, target)) {
            (*count)++;
            // 出力が多いと計測に影響するため、見つかった数だけカウントして最後に表示する形もアリですが、
            // 今回はそのまま表示します。
            for (int i = 0; i < n * n; i++) {
                printf("%2d%c", board[i], (i % n == n - 1) ? '\n' : ' ');
            }
            printf("\n");
        }
        return;
    }

    for (int i = 1; i <= n * n; i++) {
        if (!used[i]) {
            used[i] = true;
            board[step] = i;
            solve(step + 1, n, board, used, target, count);
            used[i] = false;
        }
    }
}

int main(void) {
    const int n = 3;
    const int target = n * (n * n + 1) / 2;
    int board[9] = {0};
    bool used[10] = {false};
    int found_count = 0;

    printf("%d次魔法陣の探索を開始します...\n\n", n);

    // --- 計測開始 ---
    clock_t start = clock();

    solve(0, n, board, used, target, &found_count);

    clock_t end = clock();
    // --- 計測終了 ---

    double duration = (double)(end - start) / CLOCKS_PER_SEC;

    printf("探索完了。見つかった解の数: %d\n", found_count);
    printf("実行時間: %.4f 秒\n", duration);

    return 0;
}
```

#### 5-2. 著者による考察
C言語で書くと「ただのメモリの塊をどう操作するか」という視点がより強くなります。再帰呼び出しが行われるたびに、CPUのレジスタの値がスタックに積まれ、戻るときに復元される。この一連の動作を想像しながらコードを書くことは、プログラミングの原風景に最も近い体験と言えるでしょう。

===

### 第6章 Java ―― LTS(17/21)で書く堅牢な構造

#### 6-1. 言語の壁を超えた「堅牢さ」
Javaの最大の価値は、一人法人での開発においても「数ヶ月後の自分」が迷わないための型安全性と構造化の強制にあります。特に近年のLTS（17および21）では、モダンな構文を取り入れ、冗長さを抑えつつもJavaらしい堅牢な実装が可能になっています。

##### 実装のポイント
* 6-1. 1次元配列による方陣管理：n×nの2次元盤面を1次元配列で扱い、計算効率とメモリ効率を最大化します。
* 6-2. 定数和Sによる早期枝切り：各行が埋まった瞬間に合計値を判定し、不一致なら即座にバックトラックすることで探索を高速化します。

##### Javaによる魔法陣探索の実装コード
```Java
public class MagicSquareSolver {
    private final int n;
    private final int s;           // 魔方陣定数
    private final int[] board;
    private final boolean[] used;
    private int count = 0;

    public MagicSquareSolver(int n) {
        this.n = n;
        this.s = n * (n * n + 1) / 2;
        this.board = new int[n * n];
        this.used = new boolean[n * n + 1];
    }

    public void solve() {
        backtrack(0);
        System.out.println(n + "次の魔法陣の解の総数: " + count);
    }

    private void backtrack(int pos) {
        if (pos == n * n) {
            if (checkFinal()) count++;
            return;
        }

        // 行が完成したタイミングで「和」を判定し枝切り
        if (pos > 0 && pos % n == 0) {
            int rowSum = 0;
            for (int i = pos - n; i < pos; i++) rowSum += board[i];
            if (rowSum != s) return;
        }

        for (int val = 1; val <= n * n; val++) {
            if (!used[val]) {
                used[val] = true;
                board[pos] = val;
                backtrack(pos + 1);
                used[val] = false;
            }
        }
    }

    private boolean checkFinal() {
        // 列の合計確認
        for (int c = 0; c < n; c++) {
            int colSum = 0;
            for (int r = 0; r < n; r++) colSum += board[r * n + c];
            if (colSum != s) return false;
        }
        // 対角線の合計確認
        int d1 = 0, d2 = 0;
        for (int i = 0; i < n; i++) {
            d1 += board[i * n + i];
            d2 += board[i * n + (n - 1 - i)];
        }
        return d1 == s && d2 == s;
    }

    public static void main(String[] args) {
        new MagicSquareSolver(3).solve();
    }
}
```

#### 6-2. 著者による考察
Javaでの実装は、メモリ構造を厳格に定義することから始まります。この「準備」の手間こそが、大規模な探索ロジックにおけるインデックスミスや論理破綻を防ぐ防波堤となります。AIが構造の類似性から誤って提示した他のパズルのロジックを見抜き、本来の数学的定義（和の判定）へ引き戻す工程こそが、プロの検収能力の証明です。

===

### 第7章 Rust ―― 所有権とゼロコスト抽象化がもたらす超速探索

#### 7-1. 安全性と速度の両立
Rustの最大の特徴は、ガベージコレクションなしにメモリ安全性を保証する「所有権」システムにあります。魔法陣の全探索のような、数億回以上の再帰呼び出しを伴う計算処理において、RustはC++に匹敵する実行速度を提供しつつ、並行処理におけるデータ競合をコンパイルレベルで防ぎます。

##### 実装のポイント
* 7-1. 1次元配列とスライス：盤面を Vec<i32> または固定長配列で管理し、スライスによる範囲チェックを最小限に抑えることで高速化を図ります。
* 7-2. 定数和 S による早期枝切り：各行が埋まったタイミング（pos % n == 0）で和を判定し、一致しなければ即座にリターン（バックトラック）します。
* 7-3. イテレータと再帰：Rustの強力なイテレータを使いつつ、状態の変更と復元を確実に制御します。

##### Rustによる魔法陣探索の実装コード
```Rust
struct MagicSquareSolver {
    n: usize,
    s: i32,
    board: Vec<i32>,
    used: Vec<bool>,
    count: usize,
}

impl MagicSquareSolver {
    fn new(n: usize) -> Self {
        Self {
            n,
            s: (n * (n * n + 1) / 2) as i32,
            board: vec![0; n * n],
            used: vec![false; n * n + 1],
            count: 0,
        }
    }

    fn solve(&mut self) -> usize {
        self.backtrack(0);
        self.count
    }

    fn backtrack(&mut self, pos: usize) {
        // すべてのマスが埋まった場合
        if pos == self.n * self.n {
            if self.check_final() {
                self.count += 1;
            }
            return;
        }

        // 行が完成したタイミングでの枝切り
        if pos > 0 && pos % self.n == 0 {
            let row_sum: i32 = self.board[pos - self.n..pos].iter().sum();
            if row_sum != self.s {
                return;
            }
        }

        for val in 1..=(self.n * self.n) as i32 {
            if !self.used[val as usize] {
                self.used[val as usize] = true;
                self.board[pos] = val;
                self.backtrack(pos + 1);
                self.used[val as usize] = false;
            }
        }
    }

    fn check_final(&self) -> bool {
        // 列の確認
        for c in 0..self.n {
            let mut col_sum = 0;
            for r in 0..self.n {
                col_sum += self.board[r * self.n + c];
            }
            if col_sum != self.s {
                return false;
            }
        }
        // 対角線の確認
        let mut d1 = 0;
        let mut d2 = 0;
        for i in 0..self.n {
            d1 += self.board[i * self.n + i];
            d2 += self.board[i * self.n + (self.n - 1 - i)];
        }
        d1 == self.s && d2 == self.s
    }
}

fn main() {
    let n = 3;
    let mut solver = MagicSquareSolver::new(n);
    println!("{}次の魔法陣の解の総数: {}", n, solver.solve());
}
```

#### 7-2. 著者による考察
Rustで魔法陣を解く最大のメリットは、コンパイラが「論理以外のミス」を徹底的に排除してくれる点にあります。Java以上に厳格な所有権の管理により、バックトラッキング時の中断・再開が安全に行われることが保証されます。
一人法人の開発者にとって、実行速度を稼ぐための低レイヤな工夫が、そのまま安全なコードに繋がるRustという言語は、数学的探究の最高のパートナーと言えるでしょう。

===

### 第8章 Fortran ―― 科学計算の重鎮が解く数学的秩序

#### 8-1. 伝統と進化が織りなす「数値計算の極致」
かつての固定形式から進化したFortranは、現代的な柔軟性を持ちながらも、数値計算における最適化の深さは他の追随を許しません。多次元配列の扱いや数学的表現の直感性は、魔方陣の論理を記述する上で、まさに「故郷に帰ったような」安心感と、高い計算性能を同時に提供してくれます。

##### 実装のポイント
* 8-1. フリーフォームとモジュール化：かつてのパンチカード時代の制約を脱し、モジュールとサブルーチンによる強固なカプセル化により、大規模な探索ロジックを整然と記述します。
* 8-2. 配列演算による動的枝切り：行が埋まった瞬間に配列スライスを用いて合計値を算出し、定数和 S と一致しない枝を高速に排除します。

##### Fortranによる魔方陣探索の実装コード
```Fortran
module MagicSolver
    implicit none
contains
    recursive subroutine solve(n, pos, board, used, s, count)
        integer, intent(in) :: n, s
        integer, intent(inout) :: pos, count
        integer, intent(inout) :: board(n*n)
        logical, intent(inout) :: used(n*n)
        integer :: val, row_sum

        ! すべてのマスが埋まった場合
        if (pos > n * n) then
            if (check_final(n, board, s)) count = count + 1
            return
        end if

        ! 【枝切り】行が完成したタイミングで和を判定
        if (pos > 1 .and. mod(pos-1, n) == 0) then
            row_sum = sum(board(pos-n:pos-1))
            if (row_sum /= s) return
        end if

        do val = 1, n * n
            if (.not. used(val)) then
                used(val) = .true.
                board(pos) = val
                pos = pos + 1
                call solve(n, pos, board, used, s, count)
                pos = pos - 1
                used(val) = .false.
            end if
        end do
    end subroutine solve

    function check_final(n, board, s) result(ok)
        integer, intent(in) :: n, s, board(n*n)
        logical :: ok
        integer :: i, j, c_sum, d1, d2
        ok = .true.
        do i = 1, n
            c_sum = 0
            do j = 1, n
                c_sum = c_sum + board((j-1)*n + i)
            end do
            if (c_sum /= s) then
                ok = .false.
                return
            end if
        end do
        d1 = 0; d2 = 0
        do i = 1, n
            d1 = d1 + board((i-1)*n + i)
            d2 = d2 + board((i-1)*n + (n-i+1))
        end do
        if (d1 /= s .or. d2 /= s) ok = .false.
    end function check_final
end module MagicSolver
```

#### 8-2. 著者による考察
大学時代に慣れ親しんだFortranが、現代の仕様でこれほどまでに洗練されている姿を見るのは、一人のエンジニアとして喜びを感じます。受託開発の現場でも、高度な数値シミュレーションが求められる場面では、この「計算への特化」こそが、AIが提示しがちなn-Queenのような汎用ロジックとは一線を画す、数学的に正しい解を提供してくれます。

===

### 第9章 Pascal ―― 構造化プログラミングの教育的真髄

#### 9-1. 読みやすさが育む論理的思考
Pascalは、プログラムの構造と論理を明確に記述するために設計された言語です。その厳格な構文は、魔方陣のような再帰的な全探索を記述する際にも、論理の迷子を防ぐ強力なガイドとなります。教育的な側面を持ちつつ、実用的な探索アルゴリズムを美しく記述できる点が最大の魅力です。

##### 実装のポイント
* 9-1. 厳格な型定義：Subrange type（1..N*N）などを活用し、不正な値の混入を言語レベルで防ぐPascalらしい堅牢な設計を導入します。
* 9-2. 早期枝切りによる最適化：行が埋まったタイミング（pos mod n = 0）で、現在の行の合計が魔方陣定数 S と一致するかを即座に判定します。
* 9-3. 集合型（Set）の活用：標準的なPascalでは、使用済み数字のチェックに Set を用いることで、直感的かつ高速なメンバーシップ判定が可能です。

##### Pascalによる魔方陣探索の実装コード
```Pascal
program MagicSquareSolver;

const
  N = 3;
  S = 15; { n * (n*n + 1) div 2 }

var
  Board: array[1..N*N] of Integer;
  Used: array[1..N*N] of Boolean;
  Count: Integer;

{ 行・列・対角線の最終検証 }
function CheckFinal: Boolean;
var
  R, C, SumVal, D1, D2: Integer;
  OK: Boolean;
begin
  OK := True;
  { 列の和の確認 }
  for C := 1 to N do
  begin
    SumVal := 0;
    for R := 1 to N do
      SumVal := SumVal + Board[(R-1)*N + C];
    if SumVal <> S then OK := False;
  end;
  { 対角線の和の確認 }
  D1 := 0; D2 := 0;
  for R := 1 to N do
  begin
    D1 := D1 + Board[(R-1)*N + R];
    D2 := D2 + Board[(R-1)*N + (N-R+1)];
  end;
  if (D1 <> S) or (D2 <> S) then OK := False;
  CheckFinal := OK;
end;

procedure Backtrack(Pos: Integer);
var
  Val, I, RowSum: Integer;
begin
  { 全てのマスが埋まった場合 }
  if Pos > N * N then
  begin
    if CheckFinal then Count := Count + 1;
    Exit;
  end;

  { 【枝切り】行が完成したタイミングで和を判定 }
  if (Pos > 1) and ((Pos - 1) mod N = 0) then
  begin
    RowSum := 0;
    for I := (Pos - N) to (Pos - 1) do
      RowSum := RowSum + Board[I];
    if RowSum <> S then Exit;
  end;

  for Val := 1 to N * N do
  begin
    if not Used[Val] then
    begin
      Used[Val] := True;
      Board[Pos] := Val;
      Backtrack(Pos + 1);
      Used[Val] := False;
    end;
  end;
end;

begin
  Count := 0;
  FillChar(Used, SizeOf(Used), False);
  Backtrack(1);
  WriteLn(N, ' 次の魔方陣の解の総数: ', Count);
end.
```

#### 9-2. 著者による考察
大学時代に学んだPascalの「記述の正確性」は、現代のどの言語を扱う際にも論理の基盤となっています。AIが安易に提供するn-Queenのような既存テンプレートの誤りに気づき、本来の数学的定義（魔方陣の等価性）へと引き戻す。この「検収する力」こそが、長年受託開発に携わってきたプロフェッショナルの技術的矜持です。

===

### 第10章 Go ―― 並行性とシンプルさが生む現代的パフォーマンス

#### 10-1. 現代のシステム開発における最適解
Go言語は、C言語のようなシンプルさと、現代的な並行処理機構（Goroutine）を兼ね備えた言語です。新しい言語に強い関心を持つエンジニアにとって、Goの「過不足のない設計」は、魔法陣のような探索アルゴリズムを実装する際にも、迷いのない論理構築を可能にします。

##### 実装のポイント
* 10-1. スライスの効率的な運用：Goの柔軟なスライスを使い、n * n の1次元配列として盤面を効率的に管理します。
* 10-2. 早期枝切りによる高速化：行が完成したタイミング（pos % n == 0）で和の判定を行い、不要な再帰を即座に中断します。
* 10-3. 型の厳格さと簡潔さ：複雑なクラス構造を避け、関数と構造体による素直な実装を通じて、数学的定義をダイレクトにコードへ反映させます。

##### Goによる魔法陣探索の実装コード
```Go
package main

import (
	"fmt"
)

type Solver struct {
	n     int
	s     int
	board []int
	used  []bool
	count int
}

func NewSolver(n int) *Solver {
	return &Solver{
		n:     n,
		s:     n * (n*n + 1) / 2,
		board: make([]int, n*n),
		used:  make([]bool, n*n+1),
		count: 0,
	}
}

func (sv *Solver) backtrack(pos int) {
	// すべてのマスが埋まった場合
	if pos == sv.n*sv.n {
		if sv.checkFinal() {
			sv.count++
		}
		return
	}

	// 【枝切り】行が完成したタイミングで和を判定
	if pos > 0 && pos%sv.n == 0 {
		rowSum := 0
		for i := pos - sv.n; i < pos; i++ {
			rowSum += sv.board[i]
		}
		if rowSum != sv.s {
			return
		}
	}

	for val := 1; val <= sv.n*sv.n; val++ {
		if !sv.used[val] {
			sv.used[val] = true
			sv.board[pos] = val
			sv.backtrack(pos + 1)
			sv.used[val] = false
		}
	}
}

func (sv *Solver) checkFinal() bool {
	// 列の合計確認
	for c := 0; c < sv.n; c++ {
		colSum := 0
		for r := 0; r < sv.n; r++ {
			colSum += sv.board[r*sv.n+c]
		}
		if colSum != sv.s {
			return false
		}
	}
	// 対角線の合計確認
	d1, d2 := 0, 0
	for i := 0; i < sv.n; i++ {
		d1 += sv.board[i*sv.n+i]
		d2 += sv.board[i*sv.n+(sv.n-1-i)]
	}
	return d1 == sv.s && d2 == sv.s
}

func main() {
	n := 3
	sv := NewSolver(n)
	sv.backtrack(0)
	fmt.Printf("%d次の魔法陣の解の総数: %d\n", n, sv.count)
}
```

#### 10-2. 著者による考察
新しい言語であるGoに触れる際、最も重要なのは「既存の慣習（n-Queenの解法など）を盲信せず、その言語で正しく仕様を記述する」ことです。AIが提示する曖昧なコードを、自身の経験に基づき「魔方陣の定義」へと引き戻す。この検収作業こそが、67歳のエンジニアが新しい技術を真に自分のものにするための最短ルートであると確信しています。

===

### 第11章 Kotlin ―― 簡潔さと安全性がもたらす現代的記述

#### 11-1. モダンなパラダイムの統合
KotlinはJavaとの互換性を保ちつつ、Null安全や簡潔なプロパティ記述など、現代的な機能を備えた言語です。受託開発の現場でもJavaからの移行が進むこの言語は、魔方陣のような再帰アルゴリズムを記述する際にも、ボイラープレートを排した非常に見通しの良い実装を提供してくれます。

##### 実装のポイント
* 11-1. 関数型プログラミングの導入：sumOf や filter などの標準ライブラリを活用し、行や列の合計判定を宣言的かつ簡潔に記述します。
* 11-2. 厳格な型推論と安全性：再帰呼び出しにおける引数管理を、Kotlinの強力な型システムによって安全に行い、実行時の予期せぬエラーを防ぎます。
* 11-3. 早期リターンによる枝切り：条件に合致しない分岐を即座に return するイディオムを用い、探索の効率を最大限に引き出します。

##### Kotlinによる魔方陣探索の実装コード
｀｀｀kotlin
class MagicSquareSolver(val n: Int) {
    private val s = n * (n * n + 1) / 2
    private val board = IntArray(n * n)
    private val used = BooleanArray(n * n + 1)
    var count = 0

    fun solve() {
        backtrack(0)
        println("${n}次の魔方陣の解の総数: $count")
    }

    private fun backtrack(pos: Int) {
        if (pos == n * n) {
            if (checkFinal()) count++
            return
        }

        if (pos > 0 && pos % n == 0) {
            var rowSum = 0
            for (i in (pos - n) until pos) {
                rowSum += board[i]
            }
            if (rowSum != s) return
        }

        for (valNum in 1..(n * n)) {
            if (!used[valNum]) {
                used[valNum] = true
                board[pos] = valNum
                backtrack(pos + 1)
                used[valNum] = false
            }
        }
    }

    private fun checkFinal(): Boolean {
        for (c in 0 until n) {
            var colSum = 0
            for (r in 0 until n) {
                colSum += board[r * n + c]
            }
            if (colSum != s) return false
        }
        var d1 = 0
        var d2 = 0
        for (i in 0 until n) {
            d1 += board[i * n + i]
            d2 += board[i * n + (n - 1 - i)]
        }
        return d1 == s && d2 == s
    }
}

fun main() {
    MagicSquareSolver(3).solve()
}
｀｀｀

#### 11-2. 著者による考察
Javaに慣れ親しんだエンジニアにとって、Kotlinでの実装は「記述の贅肉」を削ぎ落とす爽快な体験です。AIが過去のデータから提示しがちなn-Queenのロジックに流されることなく、魔方陣の定義という数学的本質を、最新言語の文法で再定義する。この工程こそが、新しい言語を学び続ける最大の醍醐味です。
===

### 第12章 Julia ―― 科学計算の未来を担う新星

#### 12-1. 数学的直感と圧倒的パフォーマンス
Juliaは、Pythonのような記述の平易さと、CやFortranに匹敵する実行速度を両立させた言語です。数学的な数式をそのままコードに落とし込めるような直感的な構文は、魔方陣のような「数理的秩序」を扱うプログラムにおいて、他の言語では得られない記述の喜びを提供してくれます。

##### 実装のポイント
* 12-1. 多次元配列の直感的な操作：1ベースのインデックスと強力なスライス機能を活用し、行・列・対角線の和を数学的な定義通りに記述します。
* 12-2. Just-In-Time (JIT) コンパイルによる高速化：型推論を活かした動的な最適化により、再帰的な全探索処理においても極めて高いパフォーマンスを発揮します。
* 12-3. 簡潔な枝切り論理：sum() 関数とスライスを組み合わせ、各行が完成した瞬間に制約条件を検証する無駄のない探索を実現します。

##### Juliaによる魔方陣探索の実装コード
｀｀｀julia
function solve_magic_square(n)
    s = n * (n^2 + 1) // 2  # 魔方陣定数
    board = zeros(Int, n * n)
    used = fill(false, n * n)
    count = 0

    function backtrack(pos)
        # すべてのマスが埋まった場合
        if pos > n * n
            if check_final()
                count += 1
            end
            return
        end

        # 【枝切り】行が埋まったタイミングで合計を判定
        if pos > 1 && (pos - 1) % n == 0
            row_idx = (pos - 1) ÷ n
            row_sum = sum(board[(row_idx-1)*n+1 : (row_idx-1)*n+n])
            if row_sum != s
                return
            end
        end

        for val in 1:(n * n)
            if !used[val]
                used[val] = true
                board[pos] = val
                backtrack(pos + 1)
                used[val] = false
            end
        end
    end

    function check_final()
        # 列の合計確認
        for c in 1:n
            col_sum = 0
            for r in 1:n
                col_sum += board[(r-1)*n + c]
            end
            if col_sum != s
                return false
            end
        end
        # 対角線の合計確認
        d1 = sum(board[i + (i-1)*n] for i in 1:n)
        d2 = sum(board[i + (n-i)*n] for i in 1:n)
        return d1 == s && d2 == s
    end

    backtrack(1)
    return count
end

n = 3
result = solve_magic_square(n)
println("$n 次の魔方陣の解の総数: $result")
｀｀｀

#### 12-2. 著者による考察
Juliaでの実装は、かつてFortranで感じた数値計算への没入感と、現代的な生産性が融合したような感覚を覚えます。AIが過去の統計から安易に提示するn-Queenのロジックに流されず、魔方陣という「数値の等価性」に真っ向から向き合う。これこそが、受託開発で培った数学的厳密さへの誠実さであると確信しています。

===

### 第13章 まとめ ―― 言語の壁を越えるアルゴリズムの美学

#### 13-1. 多焦点レンズが見せた「不変の論理」
本著では、C、C++、Java、Python、Fortran、Pascal、Go、Kotlin、Julia、そしてRustといった、時代も思想も異なる多様な言語で「魔方陣」を解いてきました。言語ごとに、メモリ管理の作法や並行処理の哲学は千差万別です。しかし、制約条件（魔方陣定数）に基づき枝切りを行うバックトラッキングというアルゴリズムの骨組みそのものは、どの言語においても揺らぐことはありませんでした。これこそが、特定の言語に依存しない「プログラミングの本質」であり、受託開発においても最も大切にすべき設計の根幹です。

##### 本著の要諦
* 13-1. 言語選択の審美眼：実行速度が必要なC/C++、記述の安全性が求められるRustやKotlinなど、状況に応じた「最良の道具」を選ぶ視点を得ました。
* 13-2. アルゴリズムの共通言語：どの言語で書いても変わらない「和の等価性判定」と「再帰」の論理は、エンジニアの共通言語となります。

##### 本著で触れた言語の軌跡

1. C / C++ / Java / Python
2. Fortran / Pascal
3. Go / Kotlin / Julia / Rust
｀｀｀

#### 13-2. 著者による考察
67歳というエンジニア人生の中で、多くの言語が生まれ、消えていくのを見てきました。しかし、魔方陣のような数学的な美しさを持つアルゴリズムは決して古びることはありません。一つの問題を多角的に眺めることで、視界がクリアになる感覚を覚えました。受託開発者として、新しい言語を学ぶことは単なるスキルの追加ではなく、自身の「思考のレンズ」を磨く行為に他なりません。

===

### 付録 魔法陣解法における言語別特性一覧

#### 1. 魔法陣探索に特化した「多焦点レンズ」の総括
魔法陣、特にその全探索においては、多重ループの深さと「魔方陣定数（各列の合計値）」の条件判定がパフォーマンスの鍵となります。本付録では、各言語が「魔法陣特有の計算負荷」に対し、どのような挙動を示したかを、実装の実感に基づき俯瞰的に整理します。

##### 実装のポイント
* 1-1. 計算密度の特性：単なる重複チェックだけでなく、常に「現在の合計値」を算出し、魔方陣定数と照合する計算効率を比較します。
* 1-2. 実行時オーバーヘッドの差異：マスの数だけ深くなる再帰構造の中で、言語ごとのスタック消費や関数呼び出しのコストを考察します。

##### 魔法陣解法：言語別特性比較マトリックス
｀｀｀text
| 言語          | 探索効率 | 実装の平易さ | 魔法陣実装における所感                             |
| :------------ | :------- | :----------- | :------------------------------------------------- |
| Python        | 低       | 最高         | 試作に最適。スライス機能が合計値確認に便利         |
| C++ / C       | 最高     | 中           | ビット演算での重複チェックが圧倒的に高速           |
| Java / Kotlin | 高       | 高           | 厳格な型管理が、多次元配列のインデックスミスを防ぐ |
| Rust          | 最高     | 中           | 借用チェッカーが、探索履歴の誤書き換えを未然に防ぐ |
| Fortran       | 高       | 中           | 多次元配列の扱いが直感的で、方陣の構造と一致する   |
| Pascal        | 中       | 高           | 集合型（Set）を用いた数値の重複判定が極めて明快    |
| Go            | 高       | 高           | goroutineにより、複数の枝を並列に探索可能          |
| Julia         | 高       | 高           | 数学的記述で、高速な行列演算の恩恵を受けられる     |
｀｀｀

#### 2. 著者による考察
魔法陣を解くという行為は、数学的なパズルを解くと同時に、各言語の「計算機としての素性」を剥き出しにする作業でした。受託開発者として、単に「動く」だけでなく、問題の性質に合わせて「どの言語が最もエレガントに機能するか」を見極める審美眼が重要です。
