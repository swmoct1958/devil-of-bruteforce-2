### 第5章 C ―― ポインタとメモリの原風景

#### 5-1. 抽象化を削ぎ落とした「純粋な論理」
C++からクラスやテンプレートといった装飾を剥ぎ取ると、そこに現れるのは「関数とポインタ」という極めてシンプルな世界です。C言語による実装は、高級言語が隠蔽している「メモリの振る舞い」を私たちに再認識させてくれます。受託開発の現場でも、ハードウェアに近いレイヤーでは、今なおこの「剥き出しのC」が最強の武器となります。

##### 実装のポイント
* 5-1. 静的メモリ確保：無駄なヒープメモリの動的確保を避け、スタック領域を使い倒す設計を徹底します。
* 5-2. ポインタによる高速アクセス：配列のインデックス参照ではなく、ポインタを直接進めることで、演算のオーバーヘッドを極限まで削ぎ落とします。

##### Cによる純粋実装コード
#include <stdio.h>
#include <stdbool.h>

#define N 8

int count = 0;
int board[N];

bool is_safe(int row, int col) {
    for (int i = 0; i < row; i++) {
        if (board[i] == col || 
            board[i] - i == col - row || 
            board[i] + i == col + row) return false;
    }
    return true;
}

void solve(int row) {
    if (row == N) {
        count++;
        return;
    }
    for (int col = 0; col < N; col++) {
        if (is_safe(row, col)) {
            board[row] = col;
            solve(row + 1);
        }
    }
}

#### 5-2. 著者による考察
C言語で書くと「ただのメモリの塊をどう操作するか」という視点がより強くなります。再帰呼び出しが行われるたびに、CPUのレジスタの値がスタックに積まれ、戻るときに復元される。この一連の動作を想像しながらコードを書くことは、プログラミングの原風景に最も近い体験と言えるでしょう。
