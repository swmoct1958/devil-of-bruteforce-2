# 第2章：設計図 ―― バックトラッキング法の論理

## 2-1. 言語に依存しないアルゴリズムの日本語骨子
多言語で実装を比較する前に、まずは全言語に共通する「論理の設計図」を定義します。n-Queen問題を解く最もエレガントな手法は'''バックトラッキング（後戻り法）'''です。

その基本戦略は、驚くほどシンプルです。

1. '''一行に一つずつ''': 1行目から順にクイーンを置いていく。
2. '''安全性の確認''': その場所に置いて、既存のクイーンと衝突しないか（縦・斜め）を確認する。
3. '''前進と後退''': 
   - 置ける場所があれば次行へ進む（再帰呼び出し）。
   - その行に置ける場所が一つもなければ、一行戻って（バックトラック）前の行の別の場所を試す。
4. '''終端''': 全ての行にクイーンを置けたら、一つの「解」としてカウントする。

---

## 2-2. 再帰と枝切り：配置可能判定（is_safe）の定義
「エレガントなコード」の肝は、配置可能かどうかの判定をいかに簡潔に記述できるかにあります。

### 判定の3条件
新しいクイーンを (row, col) に置く際、以下の3方向をチェックします。
* '''垂直方向（縦）''': 同じ列に他のクイーンがいないか。
* '''左斜め上方向''': 行と列の差が等しい位置に他のクイーンがいないか。
* '''右斜め上方向''': 行と列の和が等しい位置に他のクイーンがいないか。



### 共通アルゴリズムの擬似コード
'''text
関数 solve(行番号 row)
    もし row == n ならば：
        解の合計を +1 する
        戻る

    列番号 col を 0 から n-1 まで繰り返す：
        もし (row, col) に置けるならば：
            (row, col) にクイーンを配置する
            solve(row + 1)  // 次の行へ
            (row, col) からクイーンを取り除く // バックトラック
'''

## 2-3. 第2章のまとめ
このアルゴリズムの美しさは、'''「失敗したら一歩戻ってやり直す」'''という人間の思考プロセスを、再帰関数という形でそのまま記述できる点にあります。

次章からは、このシンプルな論理が、各言語の「癖」や「哲学」によってどのように肉付けされ、パフォーマンスを磨き上げられていくのかを見ていきましょう。