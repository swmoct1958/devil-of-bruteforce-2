# 全探索の悪魔 ―― 多言語実装で挑むNP問題の深淵
## n-Queen問題 ―― 10の言語で解き明かすバックトラッキングの美学
### 第0章：はじめに ―― 8つのクイーンが教えてくれること
#### 0-1. 執筆の動機：数学とプログラムの交差点
#### 0-2. クイーンの「守備範囲」と制約条件
##### 勝利の条件
#### 0-3. 本書の視点：10の多焦点レンズ
### 第1章：NP問題の深淵 ―― なぜ「全探索」なのか
#### 1-1. 未解決の「悪魔の証明」：P vs NP問題の現在
#### 1-2. $O(n!)$ の爆発：盤面拡大がもたらす絶望
### 第2章：設計図 ―― バックトラッキング法の論理
#### 2-1. 言語に依存しないアルゴリズムの日本語骨子
#### 2-2. 再帰と枝切り：配置可能判定（is_safe）の定義
##### 判定の3条件
##### 共通アルゴリズムの擬似コード
#### 2-3. 第2章のまとめ
### 第3章 Python ―― 直感と簡潔さの極み
#### Pythonが体現する「エレガンス」
##### 実装のポイント
##### 著者による考察
### 第4章：C++ ―― ビット演算によるCPUへの挑戦
#### 4-1. マシンの鼓動を感じる「厳密さ」
##### 実装のポイント
#### 4-2. 著者による考察
### 第5章：C ―― ポインタとメモリの原風景
#### 5-1. 抽象化を削ぎ落とした「純粋な論理」
##### 実装のポイント
#### 5-2. 著者による考察
### 第6章：Java ―― 堅牢な構造とLTSের 信頼
#### 6-1. エンタープライズが選ぶ「型と構造」の安心感
##### 実装のポイント
#### 6-2. 著者による考察
### 第7章：Rust ―― 所有権がもたらす安全と速度の融合
#### 7-1. 「コンパイラとの対話」が生む絶対的な安心
##### 実装のポイント
#### 7-2. 著者による考察
### 第8章：Fortran ―― 自由形式で蘇る計算の覇者
#### 8-1. 科学計算の血統と「現代的進化」
##### 実装のポイント
#### 8-2. 著者による考察
### 第9章：Pascal ―― 教育的構造の美学
#### 9-1. アルゴリズムを「記述」するための言語
##### 実装のポイント
#### 9-2. 著者による考察
### 第10章：Go ―― 究極のシンプルさと並列性の思想
#### 10-1. 「迷わせない」ためのエレガンス
##### 実装のポイント
#### 10-2. 著者による考察
### 第11章：Kotlin ―― Javaをモダンに、そして安全に
#### 11-1. Javaの不満を解消する「洗練」
##### 実装のポイント
#### 11-2. 著者による考察
### 第12章：Julia ―― 科学計算の未来を担う新星
#### 12-1. 「2つの言語問題」への終止符
##### 実装のポイント
#### 12-2. 著者による考察
### 第13章：まとめ ―― 言語の壁を越えるアルゴリズムの美学
##### 1. 実測結果の比較表 (N=13)
##### 2. 実験から得られた知見
### 付録 A-1. 言語別特性一覧
#### 付録 A-2. 各言語のリソース
