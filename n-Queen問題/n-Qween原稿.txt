# 全探索の悪魔 ―― 多言語実装で挑むNP問題の深淵
## n-Queen問題 ―― 10の言語で解き明かすバックトラッキングの美学

===

### 第0章：はじめに ―― 8つのクイーンが教えてくれること

#### 0-1. 執筆の動機：数学とプログラムの交差点
プログラミングの世界には、時代を超えて愛される「古典」があります。1848年にチェスのパズルとして提唱され、ガウスやカントールといった数学者たちをも虜にした「n-Queen問題」もその一つです。

私はこれまで、受託ソフト開発者として、C、C++、Java、Pythonといった言語を武器に、一人法人として数々の現場を歩んできました。大学時代にパンチカードでFortranやPascalを学んでから数十年。技術の流行は移ろい、言語は進化を遂げましたが、論理の核にある「美しさ」は変わることはありません。

本書の目的は、この「n-Queen問題」という一つのパズルを、古今の10のプログラミング言語で解き明かすことにあります。

#### 0-2. クイーンの「守備範囲」と制約条件
n-Queen問題を解く前に、まずチェスにおける最強の駒「クイーン」の性質を整理しておきましょう。

クイーンは、自分が位置するマスから```「縦・横・斜め」の全方向```に対して、距離に関係なく移動（攻撃）することができます。



##### 勝利の条件
$n \times n$ の盤面に $n$ 個のクイーンを配置する際、以下の条件をすべて満たさなければなりません。

1.  ```どの2つのクイーンも、お互いを攻撃できる位置にないこと```
2.  すなわち、任意の2つのクイーンは「同じ行」「同じ列」「同じ対角線」上に存在してはならない。

この単純明快なルールが、$n$ の数が増えるごとに、指数関数的な組み合わせの迷宮へと私たちを誘うのです。

#### 0-3. 本書の視点：10の多焦点レンズ
本書では、伝統的なCやFortranから、最新のRustやJuliaまで、計10の言語で同じアルゴリズムを実装します。

* ```アルゴリズムは言語を超えてどう表現されるのか```
* ```それぞれの言語が持つ独自の哲学（エレガンス）とは何か```

数学とプログラミングを愛する一人のエンジニアとして、この「多言語比較」の旅が、読者の皆様にとっても新しい発見と、かつての情熱を呼び覚ますきっかけになれば幸いです。

### 第1章：NP問題の深淵 ―― なぜ「全探索」なのか

#### 1-1. 未解決の「悪魔の証明」：P vs NP問題の現在
100万ドルの懸賞金がかけられた「ミレニアム懸賞問題」。その一つが「P vs NP予想」です。2026年現在も、この問題は完全な解決を見ていません。

簡単に言えば、「答えを見つけるのは難しいが、その答えが正しいかどうかを確認するのは簡単である」という問題のグループ（NP）が、「答えを見つけるのも、確認するのと同じくらい簡単である」というグループ（P）と同じかどうかを問うものです。

n-Queen問題はこの「NP問題」の入り口に位置します。盤面が大きくなるにつれ、正解を見つけるための試行錯誤は爆発的に増え、まさに「悪魔の証明」のごとき困難さが立ちはだかるのです。

---

#### 1-2. $O(n!)$ の爆発：盤面拡大がもたらす絶望
コンピュータの基本は「if-then」と「goto」の高速な繰り返しです。しかし、その高速性をもってしても太刀打ちできないのが「計算量の爆発」です。

n-Queen問題において、全てのマスにクイーンを置く組み合わせを力任せに調べようとすると、その数は $n^n$ や $n!$（階乗）のオーダーで増加します。



具体的な数値でその「絶望」を見てみましょう。
* **n = 8（通常のチェス盤）**: 92 解（重複あり） / 12 対称解（非同型）。現代のCPUなら一瞬です。
* **n = 15**: 組み合わせは2,279,184 通り。工夫なしでは数分を要します。
* **n = 20**: もはや家庭用PCで全探索を終えるのは現実的ではありません。

私たちは、この「指数関数的な壁」を突破するために、無駄な探索を切り捨てる「枝切り」や,ビット演算による「高速化」という技術を磨くことになります。次章では、この壁に挑むための共通の「設計図」を描いていきます。

===

### 第2章：設計図 ―― バックトラッキング法の論理

#### 2-1. 言語に依存しないアルゴリズムの日本語骨子
多言語で実装を比較する前に、まずは全言語に共通する「論理の設計図」を定義します。n-Queen問題を解く最もエレガントな手法は```バックトラッキング（後戻り法）```です。

その基本戦略は、驚くほどシンプルです。

1. ```一行に一つずつ```: 1行目から順にクイーンを置いていく。
2. ```安全性の確認```: その場所に置いて、既存のクイーンと衝突しないか（縦・斜め）を確認する。
3. ```前進と後退```: 
   - 置ける場所があれば次行へ進む（再帰呼び出し）。
   - その行に置ける場所が一つもなければ、一行戻って（バックトラック）前の行の別の場所を試す。
4. ```終端```: 全ての行にクイーンを置けたら、一つの「解」としてカウントする。

---

#### 2-2. 再帰と枝切り：配置可能判定（is_safe）の定義
「エレガントなコード」の肝は、配置可能かどうかの判定をいかに簡潔に記述できるかにあります。

##### 判定の3条件
新しいクイーンを (row, col) に置く際、以下の3方向をチェックします。
* ```垂直方向（縦）```: 同じ列に他のクイーンがいないか。
* ```左斜め上方向```: 行と列の差が等しい位置に他のクイーンがいないか。
* ```右斜め上方向```: 行と列の和が等しい位置に他のクイーンがいないか。

##### 共通アルゴリズムの擬似コード
```text
関数 solve(行番号 row)
    もし row == n ならば：
        解の合計を +1 する
        戻る

    列番号 col を 0 から n-1 まで繰り返す：
        もし (row, col) に置けるならば：
            (row, col) にクイーンを配置する
            solve(row + 1)  // 次の行へ
         
    (row, col) からクイーンを取り除く // バックトラック
```

#### 2-3. 第2章のまとめ
このアルゴリズムの美しさは、```「失敗したら一歩戻ってやり直す」```という人間の思考プロセスを、再帰関数という形でそのまま記述できる点にあります。

次章からは、このシンプルな論理が、各言語の「癖」や「哲学」によってどのように肉付けされ、パフォーマンスを磨き上げられていくのかを見ていきましょう。

===

### 第3章 Python ―― 直感と簡潔さの極み

#### Pythonが体現する「エレガンス」
Pythonの設計哲学である「The Zen of Python」には、```Simple is better than complex（複雑であるよりは、単純である方が良い）```という言葉があります。Pythonによるn-Queenの実装は、第2章で描いた「設計図」を最も美しく、そして直感的に写し取ることができます。

##### 実装のポイント
* ```再帰の素直な表現```: 複雑なポインタ操作やメモリ管理を排し、論理の構造をそのままコードにできます。
* ```動的配列（リスト）の活用```: 盤面の状態を柔軟に扱い、探索の履歴を簡潔に管理します。

##### Pythonによる実装コード
```python
import time

def solve(row, board=None):
    n = 13  # ハードコード
   
    # 1. 探索開始時（トップレベル）のみ計測開始
    if row == 0:
        solve.start_time = time.perf_counter()
        board = [-1] * n

    count = 0
    if row == n:
        return 1

    for col in range(n):
        # クイーンが置けるかどうかの判定
        safe = True
        for r in range(row):
            if board[r] == col or \
               board[r] - r == col - row or \
               board[r] + r == col + row:
  
               safe = False
               break
       
        if safe:
            board[row] = col
            count += solve(row + 1, board)
            board[row] = -1

    # 2. 探索終了時（トップレベルに戻った時）のみ結果と時間を表示
    if row == 0:
        elapsed = time.perf_counter() - solve.start_time
        print(f"Python: N={n}, Solutions={count}, Time={elapsed:.9f} sec")

    return count

if __name__ == "__main__":
    solve(0)
```
##### 著者による考察
このコードの美しさは、```「何をするか」がそのまま「書いてある」```点にあります。is_safe関数における斜めの判定 `abs(r - row) == abs(c - col)` は、数学的な定義をそのままコードに落とし込んだエレガントな表現です。

受託開発において、納期が厳しく、仕様変更が頻発するフェーズでは、このような「読み違えの起きないコード」が最大の武器になります。しかし、計算速度という面では、Pythonは広大な探索空間（n=15以上など）に対しては非力です。

次節では、この「論理」を維持したまま、速度の極限に挑むC++の世界へ足を踏み入れます。

===

### 第4章：C++ ―― ビット演算によるCPUへの挑戦

#### 4-1. マシンの鼓動を感じる「厳密さ」
C++は、Pythonとは対照的に```ハードウェアに近い場所```で動作する言語です。メモリ管理や型定義に厳格である分、開発者が意図した通りの最適化をCPUに命令することができます。

n-Queen問題において、C++がその真価を発揮するのが```ビット演算```を用いた高速化です。

##### 実装のポイント
* ```ビットフラグ```: 縦・斜めの衝突判定を、配列のループではなく「1ビットの論理演算」で瞬時に行います。
* ```インライン展開```: 関数呼び出しのオーバーヘッドを削り、実行効率を極限まで高めます。
* ```静的型付け```: コンパイル時に最適化をかけ、実行時の無駄を一切排除します。

##### C++による高速実装コード
```cpp
#include <ctime>
#include <iostream>

class NQueen {
    int all_mask;
    long count;
public:
    NQueen(int n) : all_mask((1 << n) - 1), count(0) {}

    void solve(int col, int left, int right) {
        if (col == all_mask) {
            count++;
            return;
        }
        int pos = all_mask & ~(col | left | right);
        while (pos) {
            int bit = -pos & pos;
            pos -= bit;
            solve(col | bit, (left | bit) << 1, (right | bit) >> 1);
        }
    }

    void run_with_timer() {
        clock_t start = clock();
        solve(0, 0, 0); 
        clock_t end = clock();

        double duration = (double)(end - start) / CLOCKS_PER_SEC;
        std::cout << "実行時間: " << duration << " 秒" << std::endl;
    }

    long getCount() { return count; }
};

int main() {
    NQueen engine(13);
    engine.run_with_timer();
    std::cout << "解の総数: " << engine.getCount() << std::endl;
    return 0;
}
```

#### 4-2. 著者による考察
Pythonでは「盤面の配列」を操作していましたが、このC++コードでは盤面を```ビットの連なり```として扱っています。
`(left_mask | bit) << 1` という記述一つで、「一行進むと、左斜めの利き筋が一つ隣へずれる」というチェスの物理法則を表現しています。

この「ビットで世界を記述する」感覚こそが、CやC++を扱うエンジニアが持つ特有の快感であり、受託開発においても```計算資源を最小限に抑える```ための必須技能です。

===

### 第5章：C ―― ポインタとメモリの原風景

#### 5-1. 抽象化を削ぎ落とした「純粋な論理」
C++からクラス（オブジェクト指向）の皮を剥ぎ取ると、そこに現れるのは```関数とポインタ```という極めてシンプルな世界です。C言語による実装は、高級言語が隠蔽している「メモリの振る舞い」を私たちに再認識させてくれます。

受託開発の現場でも、組み込みやOSに近いレイヤーでは、今なおこの「剥き出しのC」が最強の武器となります。

##### 実装のポイント
* ```静的メモリ確保```: 無駄なヒープメモリの動的確保を避け、スタックと静的領域を使い倒します。
* ```関数ポインタへの道標```: 今回はシンプルに再帰関数を用いますが、その構造はCPUのスタックフレームの動きをダイレクトに反映します。

##### Cによる純粋実装コード
```c
#include <stdio.h>
#include <time.h>

long long total_solutions = 0;
unsigned int all_mask;

void solve(unsigned int col_mask, unsigned int left_mask, unsigned int right_mask) {
    if (col_mask == all_mask) {
        total_solutions++;
        return;
    }

    unsigned int pos = all_mask & ~(col_mask | left_mask | right_mask);
    while (pos) {
        unsigned int bit = pos & (~pos + 1);
        pos ^= bit;
        solve(col_mask | bit, (left_mask | bit) << 1, (right_mask | bit) >> 1);
    }
}

int main() {
    int n = 13;
    all_mask = (1U << n) - 1;
    total_solutions = 0;

    clock_t start = clock();
    solve(0, 0, 0);
    clock_t end = clock();
    
    double duration = (double)(end - start) / CLOCKS_PER_SEC;
    printf("N=%d の解の総数: %lld\n", n, total_solutions);
    printf("実行時間: %.6f 秒\n", duration);

    return 0;
}
```

#### 5-2. 著者による考察
C++版とロジックは似ていますが、C言語で書くと```「ただのメモリの塊をどう操作するか」```という視点がより強くなります。



ここで注目すべきは、変数のスコープとスタックの関係です。再帰呼び出しが行われるたびに、CPUのレジスタの値がスタックに積まれ、戻るときに復元される。この一連の動作を想像しながらコードを書くことは、```「if-then/goto」の原風景```に最も近い体験と言えるでしょう。

このシンプルさゆえの強靭さが、数十年経ってもC言語が消えない理由なのです。

===

### 第6章：Java ―― 堅牢な構造とLTSের 信頼

#### 6-1. エンタープライズが選ぶ「型と構造」の安心感
Javaは、徹底したオブジェクト指向と強力な標準ライブラリを備えた言語です。受託開発において、Javaが長年主役であり続ける理由は、その```堅牢性と保守性```にあります。

n-Queen問題をJavaで解く場合、単なる計算速度だけでなく、多人数での開発にも耐えうる「構造化された美しさ」が重要になります。

##### 実装のポイント
* ```カプセル化```: 盤面の状態や計算ロジックをクラスに閉じ込め、不適切な操作を許さない設計にします。
* ```LTS（長期サポート）版の意識```: Java 17や21といったモダンな機能を活用しつつ、信頼性の高いコードを書きます。
* ```JVMによる最適化```: 実行時にJVM（Java仮想マシン）がコードを解析し、ホットスポットを自動的に最適化してくれる恩恵を享受します。

##### Javaによる構造化実装コード
```java
// public を削除して class だけで始める
#include <stdio.h>
#include <time.h>

long long total_solutions = 0;
unsigned int all_mask;

void solve(unsigned int col_mask, unsigned int left_mask, unsigned int right_mask) {
    if (col_mask == all_mask) {
        total_solutions++;
        return;
    }

    unsigned int pos = all_mask & ~(col_mask | left_mask | right_mask);
    while (pos) {
        unsigned int bit = pos & (~pos + 1);
        pos ^= bit;
        solve(col_mask | bit, (left_mask | bit) << 1, (right_mask | bit) >> 1);
    }
}

int main() {
    int n = 13;
    all_mask = (1U << n) - 1;
    total_solutions = 0;

    clock_t start = clock();
    solve(0, 0, 0);
    clock_t end = clock();
    
    double duration = (double)(end - start) / CLOCKS_PER_SEC;
    printf("N=%d の解の総数: %lld\n", n, total_solutions);
    printf("実行時間: %.6f 秒\n", duration);

    return 0;
}
```

#### 6-2. 著者による考察
Javaの実装で特筆すべきは、右シフト演算子の `>>>`（無符号右シフト）です。C言語などでは符号ビットの扱いに注意が必要ですが、Javaはこうした細部まで言語仕様として厳格に定義されています。

また、Javaで書くということは、```「JVMという巨大な知性」の上にロジックを載せる```という感覚に近いです。最初はC++より遅くても、実行を繰り返すうちにJITコンパイラが最適化を行い、驚くほどのパフォーマンスを見せるようになります。

この「予測可能な堅牢さ」こそが、多くの法人がJavaを指名する最大の理由であり、プロフェッショナルの道具としてのエレガンスなのです。

===

### 第7章：Rust ―― 所有権がもたらす安全と速度の融合

#### 7-1. 「コンパイラとの対話」が生む絶対的な安心
Rustは、現代のプログラミング言語の中で最も勢いのある言語の一つです。その最大の特徴は、```所有権（Ownership）```という独自の概念によって、実行速度を一切犠牲にすることなく「メモリ安全」を実現している点にあります。

受託開発において、最もコストがかかるのは「本番環境でのみ発生するメモリバグ」の修正です。Rustは、そのようなバグをコンパイル時に徹底的に排除します。

##### 実装のポイント
* ```ゼロコスト抽象化```: 高級な記述をしても、コンパイル後の機械語はC/C++と同等にまで最適化されます。
* ```安全な並列化への布石```: 今回はシングルスレッドですが、Rustの構造は将来的なマルチスレッド化（並列探索）への移行を極めて容易にします。

##### Rustによる安全・高速実装コード
```rust
use std::time::Instant;
// 外部変数（スタック）の代わりにミュータブルな参照でカウントを渡す
fn solve(all_mask: u32, col_mask: u32, left_mask: u32, right_mask: u32, total_solutions: &mut i64) {
    if col_mask == all_mask {
        *total_solutions += 1;
        return;
    }

    let mut pos = all_mask & !(col_mask | left_mask | right_mask);
    while pos != 0 {
        let bit = pos & (!pos + 1);
        // 最下位ビットの抽出
        pos ^= bit;
        solve(
            all_mask,
            col_mask | bit,
            (left_mask | bit) << 1,
            (right_mask | bit) >> 1,
            total_solutions,
        );
    }
}

fn main() {
    let n = 13;
    let all_mask = (1u32 << n) - 1;
    let mut total_solutions = 0i64;

    // --- ここから計測開始 ---
    let start = Instant::now();
    solve(all_mask, 0, 0, 0, &mut total_solutions);

    let end = Instant::now();
    // --- ここで計測終了 ---

    let duration = end.duration_since(start);

    println!("N={} の解の総数: {}", n, total_solutions);
    println!("実行時間: {:.6} 秒", duration.as_secs_f64());
}
```

#### 7-2. 著者による考察
Rustのコードを書いていて感じるのは、```「コンパイラが最も頼もしい相棒になる」```という感覚です。

CやC++では、プログラマが細心の注意を払ってメモリを管理していましたが、Rustではコンパイラがその責任を引き受けてくれます。この「厳格さ」は、一見すると不自由に見えるかもしれませんが、大規模・高難度の受託案件においては、これほど心強いものはありません。

「if-then/goto」の制御構造を保ちつつ、現代的な「安全性」という鎧を纏ったRustは、まさに```古典と現代の最高の融合```と言えるでしょう。

===

### 第8章：Modern Fortran ―― 自由形式で蘇る計算の覇者

#### 8-1. 科学計算の血統と「現代的進化」
Fortranは、世界初の高水準言語として誕生して以来、一貫して「数値計算」の効率を追求してきました。大学時代にパンチカードや固定形式で触れた世代にとって、現在の```自由形式（Free Form）```のFortranは、全く別の洗練された言語に見えるかもしれません。

しかし、その根底にある「計算に対する愚直なまでの誠実さ」は変わっていません。

##### 実装のポイント
* ```再帰呼び出しの明示```: `recursive` キーワードを用い、アルゴリズムの意図を明確にします。
* ```配列演算の強力さ```: 今回はビット演算を用いますが、Fortran本来の強みである配列操作の直感性も、この言語のエレガンスの一部です。
* ```副作用の排除```: `pure` や `intent` を活用し、受託開発でも重要な「バグの入り込まない関数設計」を徹底できます。

##### Modern Fortranによる実装コード
```fortran
program n_queen
  implicit none
  integer :: n, all_mask
  integer(8) :: total
  real :: start, finish

  n = 13
  all_mask = iand(ishft(1, n) - 1, z'ffffffff')
  total = 0

  call cpu_time(start)
  call solve(0, 0, 0, all_mask, total)
  call cpu_time(finish)

  print *, "N =", n
  print *, "Total Solutions:", total
  print *, "Time (sec):", finish - start

contains

  recursive subroutine solve(col_mask, left_mask, right_mask, all_mask, total)
    integer, intent(in) :: col_mask, left_mask, right_mask, all_mask
    integer(8), intent(inout) :: total
    integer :: pos, bit

    if (col_mask == all_mask) then
      total = total + 1
    else
      pos = iand(all_mask, not(ior(ior(col_mask, left_mask), right_mask)))
      do while (pos /= 0)
        bit = iand(pos, -pos)
        pos = pos - bit
        call solve(ior(col_mask, bit), &
                   ishft(ior(left_mask, bit), 1), &
                   ishft(ior(right_mask, bit), -1), &
                   all_mask, total)
      end do
    end if
  end subroutine solve

end program n_queen
```
#### 8-2. 著者による考察
Modern Fortranのコードは、意外なほどモダンで読みやすいことに驚かれるかもしれません。`iand`（論理積）や `ishft`（ビットシフト）といった組み込み関数は、```プロセッサの命令セットに直結```しており、数値計算における実行効率は今なおトップクラスです。

受託開発の世界では目にする機会が減りましたが、巨大な行列演算や物理シミュレーションの現場では、Fortranは「現役の王者」です。古き良き「計算機」としての誇りと、現代的な「構造化」が同居するこの言語でn-Queenを解くことは、```自分のプログラミングのルーツを再発見する```ような、深い趣があります。

===

### 第9章：Pascal ―― 教育的構造の美学

#### 9-1. アルゴリズムを「記述」するための言語
Pascalは、計算機科学の巨星ニクラウス・ヴィルトによって「教育用」として設計されました。しかし、その厳格な型チェックと美しいブロック構造は、実用言語としても極めて優秀でした。

n-Queen問題をPascalで書くと、コードがまるで```アルゴリズムの教科書```そのものであるかのように整然と並びます。

##### 実装のポイント
* ```BEGIN-ENDブロック```: 処理の境界を明示し、入れ子構造を視覚的に理解しやすくします。
* ```厳格な宣言部```: 変数宣言をコードの冒頭に強制することで、プログラマの思考を整理させます。
* ```集合（Set）の概念```: Pascal特有の強力な集合型がありますが、今回は他言語との比較のため、ビット演算による実装を行います。

##### Pascal (Free Pascal) による実装コード
```pascal
program NQueenPascal;

uses
  sysutils, dateutils;

const
  N = 13;

var
  all_mask: Integer;
  total_solutions: Int64;
  StartTime, EndTime: TDateTime;
  ElapsedSeconds: Double;

procedure solve(col_mask, left_mask, right_mask: Integer);
var
  pos, bit: Integer;
begin
  if col_mask = all_mask then
  begin
    total_solutions := total_solutions + 1;
    exit;
  end;

  pos := all_mask and not (col_mask or left_mask or right_mask);
  while pos <> 0 do
  begin
    bit := pos and -pos;
    pos := pos xor bit;
    solve(col_mask or bit, (left_mask or bit) shl 1, (right_mask or bit) shr 1);
  end;
end;

begin
  total_solutions := 0;
  all_mask := (1 shl N) - 1;

  writeln('N=', N, ' で計算開始...');
  StartTime := Now;

  solve(0, 0, 0);

  EndTime := Now;
  ElapsedSeconds := MilliSecondsBetween(StartTime, EndTime) / 1000.0;

  writeln('解の総数: ', total_solutions);
  writeln('実行時間: ', ElapsedSeconds:0:3, ' 秒');
end.
```

#### 9-2. 著者による考察
Pascalのコードには、独特の```「気品」```があります。`=` ではなく `:=` を代入に使うといった細かな約束事の一つ一つが、「今、自分はコンピュータに厳密な命令を与えているのだ」という自覚を促してくれます。

大学時代にこの言語で基礎を学んだ経験は、その後のCやJava、Pythonといった多種多様な言語を習得する際の```「揺るぎない背骨」```となったはずです。効率だけを追い求める現代において、Pascalの持つ「正しく書かせる」という哲学を再考することは、プロフェッショナルな開発者にとって非常に意義深い体験と言えるでしょう。

===

### 第10章：Go ―― 究極のシンプルさと並列性の思想

#### 10-1. 「迷わせない」ためのエレガンス
Go（Golang）の設計思想は、徹底した```ミニマリズム```にあります。C++やJavaが多機能化する一方で、Goはあえて機能を絞り込むことで、誰が書いても同じようなコードになるよう設計されています。

この「予測可能性」は、チームで動く受託開発において極めて強力なメリットとなります。

##### 実装のポイント
* ```簡潔な文法```: while文すらなく、ループはすべて `for` に統一されています。
* ```高速なコンパイル```: C言語に近い実行速度を持ちながら、ビルドは一瞬で終わります。
* ```並列処理（Goroutine）への拡張性```: 今回は基本実装ですが、Goは将来的に数百万の並列探索を走らせることも容易です。

##### Goによる「質実剛健」な実装コード
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    n := 13
    allMask := (1 << n) - 1
    count := 0

    var solve func(int, int, int)
    solve = func(colMask, leftMask, rightMask int) {
        if colMask == allMask {
            count++
            return
        }

        pos := allMask &^ (colMask | leftMask | rightMask)

        for pos != 0 {
            bit := pos & -pos
            pos ^= bit
            solve(colMask|bit, (leftMask|bit)<<1, (rightMask|bit)>>1)
        }
    }

    start := time.Now()
    solve(0, 0, 0)
    elapsed := time.Since(start)

    fmt.Printf("N=%d の解の総数: %d\n", n, count)
    fmt.Printf("実行時間: %f 秒\n", elapsed.Seconds())
}
```

#### 10-2. 著者による考察
Goのコードには、飾り気がありません。例えばビット反転の演算子に `^` ではなく `&^`（bit clear）を採用している点など、```「曖昧さを許さない」```という強い意志を感じます。

受託開発者として60代を迎え、多くの複雑なシステムを見てきた目で見ると、Goのような「削ぎ落とされた美」には一種の安らぎさえ覚えます。「if-then/goto」の論理を、最も現代的で、かつ最もノイズの少ない形で記述できるのが、このGoという言語なのです。

===


### 第11章：Kotlin ―― Javaをモダンに、そして安全に

#### 11-1. Javaの不満を解消する「洗練」
Kotlinは、Javaの堅牢さを引き継ぎながら、```ボイラープレート（定型的なコード）```を徹底的に排除したその姿は、ベテラン開発者にとっても非常に心地よいものです。

##### 実装のポイント
* ```Null安全```: 実行時エラーの最大の原因であるNullポインタ例外を、コンパイル時に防ぎます。
* ```簡潔な関数定義```: `fun` キーワードを用いた数学的な関数記述が可能です。
* ```演算子の直感性```: `inv()`（ビット反転）や `shl`（左シフト）など、ビット演算もメソッドのように美しく記述できます。

##### Kotlinによる「スマート」な実装コード
```kotlin
import kotlin.system.measureTimeMillis

const val N = 13
var allMask: Int = 0
var totalSolutions: Long = 0

fun solve(colMask: Int, leftMask: Int, rightMask: Int) {
    if (colMask == allMask) {
        totalSolutions++
        return
    }

    var pos = allMask and (colMask or leftMask or rightMask).inv()

    while (pos != 0) {
        val bit = pos and -pos
        pos = pos xor bit
        solve(colMask or bit, (leftMask or bit) shl 1, (rightMask or bit) ushr 1)
    }
}

fun main() {
    totalSolutions = 0
    allMask = (1 shl N) - 1

    println("N=$N で計算開始...")
    
    val time = measureTimeMillis {
        solve(0, 0, 0)
    }

    println("解の総数: $totalSolutions")
    println("実行時間: ${time / 1000.0} 秒")
}
```

#### 11-2. 著者による考察
Java（第6章）と比較すると、同じロジックを書きながらも、コードの「ノイズ」がいかに減っているかが分かります。Kotlinは、Javaが積み上げてきた信頼という遺産を活かしつつ、Python（第3章）のような軽快さを手に入れた言語です。受託開発においても、```「保守性の高さ」と「書く楽しさ」```を両立させてくれる、非常にバランスの取れた選択肢と言えるでしょう。

===

### 第12章：Julia ―― 科学計算の未来を担う新星

#### 12-1. 「2つの言語問題」への終止符
これまで、研究や試作はPythonで行い、本番の高速化にはC++で書き直すという「2つの言語問題（Two-Language Problem）」が開発者を悩ませてきました。Juliaはこの壁を打ち破るために誕生しました。

```JIT（Just-In-Time）コンパイル```により、スクリプト言語の手軽さでありながら、コンパイル言語に匹敵するパフォーマンスを叩き出します。

##### 実装のポイント
* ```数学的な親和性```: 数式をそのまま書くような直感的な記述が可能です。
* ```型推論と型注釈```: 基本は動的ですが、型を意識した設計により、コンパイラが極限まで最適化を行います。

##### Juliaによる「高効率」な実装コード
```julia
using Printf

const N = 13

function solve(col_mask, left_mask, right_mask, all_mask)
    if col_mask == all_mask
        return 1
    end

    total = 0
    pos = all_mask & ~(col_mask | left_mask | right_mask)

    while pos != 0
        bit = pos & -pos
        pos = xor(pos, bit)
        total += solve(col_mask | bit, (left_mask | bit) << 1, (right_mask | bit) >> 1, all_mask)
    end
    return total
end

function run_nqueen()
    all_mask = (1 << N) - 1
    println("N=$N で計算開始...")
    
    start_time = time()
    solutions = solve(0, 0, 0, all_mask)
    end_time = time()
    
    elapsed = end_time - start_time
    
    @printf("解の総数: %d\n", solutions)
    @printf("実行時間: %.3f 秒\n", elapsed)
end

run_nqueen()
```

#### 12-2. 著者による考察
Juliaでn-Queenを書くと、そのコードの短さはPython（第3章）に近く、実行速度はC++（第4章）に近いという、魔法のような感覚を味わえます。受託開発の現場でも、特にデータ分析や高度なアルゴリズムの実装が求められる案件では、Juliaという選択肢を知っているだけで、提案の幅が大きく広がります。

===

### 第13章：まとめ ―― 言語の壁を越えるアルゴリズムの美学

本稿では、n-Queen問題を題材に、全12種類の言語でその実行速度を検証してきました。

##### 1. 実測結果の比較表 (N=13)
| 順位 | 言語 | 平均実行時間 (sec) | 特徴・備考 |
| :--- | :--- | :--- | :--- |
| 1 | Java | 0.0307 | JVMの動的最適化が極めて優秀 |
| 1 | Kotlin | 0.0307 | Javaと並び、現代のランタイムの強さを見せた |
| 3 | Go | 0.0313 | 簡潔な記述と実行速度のバランスが秀逸 |
| 4 | Rust | 0.0317 | メモリ安全性と最高峰の速度を両立 |
| 5 | Julia | 0.0327 | 数値計算に強いJITコンパイルの成果 |
| 6 | C | 0.0470 | すべての言語の原点。依然として高い信頼性 |
| 7 | C++ | 0.0487 | Cと並び、ハードウェアに近い制御が可能 |
| 8 | Pascal | 0.0550 | 構造化言語の先駆者。現代でも通用する |
| 9 | Python | 27.0660 | 開発効率と引き換えに、計算速度は譲る |

##### 2. 実験から得られた知見
* **「C/C++最強説」の変遷**: 現代のJITランタイム（Java/Julia）は、特定の条件下でCを凌駕するほど進化しています。
* **抽象化と速度のトレードオフ**: Pythonの27秒という結果は、適材適所の判断がエンジニアに不可欠であることを示しています。
* **ビット演算という共通言語**: 言語という「名前」が異なっても、最深部で行われている論理の本質は一つです。

---

### 付録 A-1. 言語別特性一覧

| 章 | 言語 | 主要な哲学 | 実装の特徴（n-Queen） |
| :--- | :--- | :--- | :--- |
| 第3章 | **Python** | 可読性とシンプルさ | 擬似コードのように論理を直書きできる。 |
| 第4章 | **C++** | ゼロコスト抽象化 | ビット演算による極限の高速化が可能。 |
| 第5章 | **C** | ハードウェアの制御 | ポインタとスタックを意識した純粋な論理。 |
| 第6章 | **Java** | 堅牢性と保守性 | 大規模開発への適性。 |
| 第7章 | **Rust** | 安全性と速度 | 所有権システムによるメモリ安全の保証。 |
| 第8章 | **Fortran** | 科学技術計算の王道 | 数値計算への絶対的な信頼性。 |
| 第9章 | **Pascal** | 教育的構造美 | 厳格な記述を求める、アルゴリズムの教科書。 |
| 第10章 | **Go** | 実用的な簡潔さ | メンテナンス性の極致。 |
| 第11章 | **Kotlin** | モダンな洗練 | Javaの遺産を活かしつつ、洗練された記述。 |
| 第12章 | **Julia** | 速度と手軽さの両立 | 動的な書き心地でC並の計算速度。 |

#### 付録 A-2. 各言語のリソース
* **C/C++**: [https://isocpp.org/](https://isocpp.org/)
* **Java**: [https://dev.java/](https://dev.java/)
* **Rust**: [https://www.rust-lang.org/](https://www.rust-lang.org/)
* **Fortran**: [https://fortran-lang.org/](https://fortran-lang.org/)
* **Go**: [https://go.dev/](https://go.dev/)
* **Julia**: [https://julialang.org/](https://julialang.org/)

