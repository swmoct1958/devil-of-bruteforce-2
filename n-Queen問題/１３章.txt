## 第13章：まとめ ―― 言語の壁を越えるアルゴリズムの美学

本稿では、エイト・クイーンから始まる N-Queens パズルを題材に、全12種類のプログラミング言語でその実行速度を検証してきました。ここでは、その実験結果を総括し、現代のプログラミングと言語選択の在り方について考察します。

### 1. 実測結果の比較表
同一のアルゴリズム（ビット演算を用いた再帰探索）を用い、筆者の開発環境（Windows 11）にて N=13 の解を求めた際の平均実行時間（AVG）の結果です。

| 順位 | 言語 | 平均実行時間 (sec) | 特徴・備考 |
| :--- | :--- | :--- | :--- |
| 1 | Java | 0.0307 | JVMの動的最適化が極めて優秀 |
| 1 | Kotlin | 0.0307 | Javaと並び、現代のランタイムの強さを見せた |
| 3 | Go | 0.0313 | 簡潔な記述と実行速度のバランスが秀逸 |
| 4 | Rust | 0.0317 | メモリ安全性と最高峰の速度を両立 |
| 5 | Julia | 0.0327 | 数値計算に強いJITコンパイルの成果 |
| 6 | C | 0.0470 | すべての言語の原点。依然として高い信頼性 |
| 7 | C++ | 0.0487 | Cと並び、ハードウェアに近い制御が可能 |
| 8 | Pascal | 0.0550 | 構造化言語の先駆者。現代でも十分通用する |
| 9 | Python | 27.0660 | 開発効率と引き換えに、計算速度は他を譲る |



---

### 2. 実験から得られた知見

1. **「C/C++最強説」の変遷**
かつて受託開発の現場では「速度ならC」が絶対的な正解でした。しかし今回の結果では、JavaやJuliaなどの「実行時コンパイル（JIT）」を持つ言語が、特定のアルゴリズムにおいてCを凌駕する場面が見られました。これは現代のランタイムがいかに進化しているかを象徴しています。

2. **抽象化と速度のトレードオフ**
Pythonの27秒という結果は、他のコンパイラ言語より約800倍以上の時間を要していることを示しています。これはスクリプト言語の宿命ではありますが、開発速度と実行速度のどちらを優先すべきかという「適材適所」の判断が、エンジニアには求められます。

3. **ビット演算という共通言語**
アンリ・ポアンカレは、「数学とは、異なるものに同じ名前を与える技術である」と述べました。今回、12の異なる言語で同じアルゴリズムを実装しましたが、最深部で行われているビット操作の本質はすべて同じです。優れたアルゴリズムは、言語という「名前」の違いを超えて、コンピュータの性能を極限まで引き出す普遍的な力を持っています。

---

### 3. おわりに
大学時代に触れたFortranやPascalから、現代のRustやJuliaまで、50年近い月日を経て様々な言語を巡ってきました。受託ソフト開発者として多くの実用システムを構築してきましたが、趣味として純粋にアルゴリズムと向き合うプログラミングには、また別の格別な楽しさがあります。

言語は道具に過ぎませんが、その道具を深く知ることは、コンピュータそのものを知ることに繋がります。読者の皆様も、ぜひ一つの言語に固執せず、複数の言語で同じ問題を解いてみてください。そこには、新しい世界の見え方が広がっているはずです。
